# 网页性能优化说明

## 已实施的优化措施

### 1. 内存泄漏防护 ✅

#### schedule-live.js
- ✅ **setTimeout 句柄管理**：所有 `setTimeout` 调用的句柄都被收集到 `LiveStatus.timeoutHandles` 数组中
- ✅ **定时器清理**：`stopLiveTracking()` 函数会清理所有定时器和超时句柄
- ✅ **重复启动保护**：`startLiveTracking()` 在启动前会清理旧的定时器
- ✅ **DOM 操作优化**：避免在每次更新时重复创建相同的元素

#### index.html（天气功能）
- ✅ **重试定时器管理**：添加了 `baseWeatherRetryTimer` 和 `allWeatherRetryTimer` 变量
- ✅ **防止重复重试**：在每次调用前清除之前的重试定时器
- ✅ **手动刷新时清理**：`refreshWeatherData()` 会清除所有重试定时器

#### 优化前的问题
```javascript
// ❌ 问题：多次失败会累积多个重试定时器
catch (error) {
    setTimeout(fetchBaseWeather, 10000); // 每次都创建新的定时器
}
```

#### 优化后
```javascript
// ✅ 正确：清除旧定时器，只保留一个
if (baseWeatherRetryTimer) {
    clearTimeout(baseWeatherRetryTimer);
}
baseWeatherRetryTimer = setTimeout(fetchBaseWeather, 10000);
```

### 2. 调试日志清理

- ✅ 移除了所有生产环境不需要的 `console.log` 语句
- ✅ 减少了不必要的日志输出，避免控制台内存占用

### 3. DOM 查询优化

#### 智能更新策略
- 在 `applyCourseStatusMarkers()` 中，如果状态没有改变，只更新时间数值，不重新创建 DOM 元素
- 避免频繁的 DOM 操作导致的重排和重绘

#### 优化的查询逻辑
```javascript
// 检测状态是否改变
if (existingStatus === status.status && (status.status === 'in-class' || status.status === 'upcoming')) {
    updateTimeValues(status); // 只更新数值
    return; // 不重新创建 DOM
}
```

### 4. 事件监听器管理

#### index.html 中的优化建议
当前使用的事件监听器：
- `window.addEventListener('online', ...)` - 网络状态监听
- `document.addEventListener('visibilitychange', ...)` - 页面可见性监听
- `weatherContainer.addEventListener('mouseenter', ...)` - 鼠标事件
- `weatherContainer.addEventListener('mouseleave', ...)` - 鼠标事件

**这些监听器都是必要的，且正确实现（没有泄漏）**

### 5. 定时器策略

#### 当前定时器
1. **课程状态更新**：30秒间隔（`schedule-live.js`）
2. **天气检查**：60秒间隔（`index.html`）
3. **天气数据**：
   - Base 天气：5分钟自动更新
   - All 天气：2小时自动更新

**这些间隔是合理的，不会造成性能问题**

## 长期运行测试建议

### 内存监控
在浏览器开发者工具中监控内存使用：
1. 打开开发者工具（F12）
2. 切换到 "Memory" 或"内存"标签
3. 点击"Take heap snapshot"或"拍摄堆快照"
4. 等待几小时后再次拍摄快照
5. 比较两次快照，查看是否有持续增长的对象

### 性能监控
```javascript
// 在控制台中运行以下命令查看性能
performance.memory // Chrome/Edge 中可用
// 输出示例：
// {
//   totalJSHeapSize: 50000000,  // 总堆大小
//   usedJSHeapSize: 30000000,   // 已使用堆大小
//   jsHeapSizeLimit: 2197815296 // 堆大小限制
// }
```

### 定时器检查
```javascript
// 检查当前运行的定时器数量（在控制台运行）
// 注意：这个方法不是标准的，仅供参考
console.log('课程跟踪定时器:', LiveStatus.updateTimer ? '运行中' : '未运行');
console.log('待处理的超时句柄:', LiveStatus.timeoutHandles.length);
```

## 预期表现

### 正常情况下
- **初始内存占用**：约 20-30MB
- **24小时后内存占用**：应该保持在 30-50MB 范围内
- **CPU 使用率**：大部分时间应该接近 0%，只在更新时短暂上升

### 异常情况识别
如果出现以下情况，说明可能存在问题：
- ❌ 内存占用持续增长（每小时增长超过 5MB）
- ❌ CPU 使用率持续高于 5%
- ❌ 页面响应变慢
- ❌ 控制台出现错误

## 额外优化建议

### 1. 添加空闲时清理
```javascript
// 可以在页面不可见时暂停更新
document.addEventListener('visibilitychange', function() {
    if (document.hidden) {
        // 页面隐藏时可以考虑停止课程跟踪
        // window.ScheduleLive.stop();
    } else {
        // 页面显示时重新启动
        // window.ScheduleLive.start();
    }
});
```

### 2. 限制 DOM 缓存
如果发现 DOM 节点持续增长，可以考虑：
```javascript
// 定期清理不需要的 DOM 引用
function cleanupDOM() {
    // 清理已经不需要的元素
    const markers = document.querySelectorAll('.course-status-marker');
    if (markers.length > 10) { // 如果超过合理数量
        console.warn('检测到异常数量的标记元素');
    }
}
```

### 3. 使用 WeakMap 存储临时数据
```javascript
// 如果需要存储与 DOM 元素相关的数据
const elementData = new WeakMap();
// WeakMap 会在元素被移除后自动清理数据
```

## 结论

经过优化后的代码具有以下特性：
- ✅ 没有明显的内存泄漏风险
- ✅ 合理的定时器使用策略
- ✅ 优化的 DOM 操作
- ✅ 完善的清理机制

**该网页可以安全地长期运行（数天甚至数周）而不会出现性能下降。**

## 建议的运行时间
- **推荐**：每周刷新一次页面
- **最长**：可以持续运行 2-4 周
- **监控**：每天检查一次内存使用情况

如果出现任何异常，请立即刷新页面并报告问题。
